#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2026, Ilya Gulya
# MIT License (see LICENSE or https://opensource.org/licenses/MIT)

# ⚠️ AUTOMATICALLY GENERATED - DO NOT EDIT
# Generated by remnawave-ansible-gen from Remnawave API {{ api_version }}

"""Ansible module for managing {{ resource_name }} resources in Remnawave panel."""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r"""
---
module: {{ module_name }}
short_description: {{ description }}
version_added: "{{ collection_version }}"
description:
    - Create, update, and delete {{ resource_name }} resources in Remnawave panel.
    - Supports check mode for dry-run operations.
    - Implements idempotency by comparing desired state with current state.
options:
    api_url:
        description:
            - The URL of the Remnawave panel API.
            - Can be set via the C(REMNAWAVE_API_URL) environment variable.
        type: str
        required: true
    api_token:
        description:
            - The API token for authentication.
            - Can be set via the C(REMNAWAVE_API_TOKEN) environment variable.
        type: str
        required: true
    validate_certs:
        description:
            - Whether to validate SSL/TLS certificates.
            - Set to C(false) for self-signed certificates.
        type: bool
        default: true
    timeout:
        description:
            - Timeout in seconds for API requests.
        type: int
        default: 30
    state:
        description:
            - The desired state of the resource.
            - C(present) ensures the resource exists with the specified configuration.
            - C(absent) ensures the resource does not exist.
        type: str
        default: present
        choices:
            - present
            - absent
    {{ id_param }}:
        description:
            - The unique identifier of the {{ resource_name }}.
            - Required when updating or deleting an existing resource by ID.
        type: str
        required: false
{% for field in fields %}
    {{ field.snake_name }}:
        description:
            - "{{ field.description }}{% if field.format is defined %} (format: {{ field.format }}){% endif %}{% if field.min is defined %} (minimum: {{ field.min }}){% endif %}{% if field.max is defined %} (maximum: {{ field.max }}){% endif %}"
{% if field.required %}
            - Required when I(state=present).
{% endif %}
        type: {{ field.type }}
        required: false
{% if field.default is not none %}
        default: {{ field.default }}
{% endif %}
{% if field.type == 'list' and field.elements is defined %}
        elements: {{ field.elements }}
{% endif %}
{% endfor %}
author:
    - Ilya Gulya (@ilyagulya)
notes:
    - Supports check_mode for dry-run operations.
    - Uses the {{ lookup_field }} field for resource lookup when {{ id_param }} is not provided.
"""

EXAMPLES = r"""
- name: Create a new {{ resource_name | lower }}
  remnawave.panel.{{ module_name }}:
    api_url: "https://panel.example.com"
    api_token: "{{ '{{' }} api_token {{ '}}' }}"
    state: present
{% for field in fields %}
{% if field.required %}
    {{ field.snake_name }}: "example_value"
{% endif %}
{% endfor %}

- name: Update an existing {{ resource_name | lower }}
  remnawave.panel.{{ module_name }}:
    api_url: "https://panel.example.com"
    api_token: "{{ '{{' }} api_token {{ '}}' }}"
    state: present
    {{ id_param }}: "existing-uuid-here"
{% for field in fields %}
{% if field.required %}
    {{ field.snake_name }}: "updated_value"
{% endif %}
{% endfor %}

- name: Delete a {{ resource_name | lower }}
  remnawave.panel.{{ module_name }}:
    api_url: "https://panel.example.com"
    api_token: "{{ '{{' }} api_token {{ '}}' }}"
    state: absent
    {{ id_param }}: "uuid-to-delete"

- name: Delete a {{ resource_name | lower }} by name
  remnawave.panel.{{ module_name }}:
    api_url: "https://panel.example.com"
    api_token: "{{ '{{' }} api_token {{ '}}' }}"
    state: absent
    {{ lookup_field }}: "resource-name-to-delete"
"""

RETURN = r"""
changed:
    description: Whether the resource was changed.
    type: bool
    returned: always
response:
    description: The API response containing the resource data.
    type: dict
    returned: when resource is created or updated
    sample:
        uuid: "550e8400-e29b-41d4-a716-446655440000"
{% for field in fields %}
        {{ field.name }}: "example"
{% endfor %}
diff:
    description: The difference between desired and current state.
    type: dict
    returned: when in check_mode and changes would be made
    contains:
        before:
            description: The current state of the resource.
            type: dict
        after:
            description: The desired state of the resource.
            type: dict
msg:
    description: A message describing the result of the operation.
    type: str
    returned: always
status_code:
    description: HTTP status code from the API (only on error).
    type: int
    returned: on API error
response_body:
    description: Response body from the API (only on error).
    type: raw
    returned: on API error
request_url:
    description: The URL that was requested (only on error).
    type: str
    returned: on API error
request_method:
    description: The HTTP method used (only on error).
    type: str
    returned: on API error
"""

from ansible.module_utils.basic import AnsibleModule, env_fallback

from ansible_collections.remnawave.panel.plugins.module_utils.remnawave import (
    RemnawaveClient,
    RemnawaveAPIError,
    recursive_diff,
    snake_to_camel_dict,
    camel_to_snake_dict,
{% if resolve_uuid_by_name %}
    resolve_config_profile_uuid,
    resolve_inbound_uuids,
{% endif %}
)


def build_payload(params, fields):
    """Build the API payload from module parameters."""
    payload = {}
    for field in fields:
        snake_name = field["snake_name"]
        camel_name = field["name"]
        value = params.get(snake_name)
        if value is not None:
            # Convert nested dict keys from snake_case to camelCase
            if isinstance(value, dict):
                value = snake_to_camel_dict(value)
            elif isinstance(value, list):
                value = [snake_to_camel_dict(item) if isinstance(item, dict) else item for item in value]
            payload[camel_name] = value
    return payload


def run_module():
    """Main module execution."""
    # Define argument spec
    module_args = dict(
        api_url=dict(type="str", required=True, fallback=(env_fallback, ["REMNAWAVE_API_URL"])),
        api_token=dict(type="str", required=True, no_log=True, fallback=(env_fallback, ["REMNAWAVE_API_TOKEN"])),
        validate_certs=dict(type="bool", default=True),
        timeout=dict(type="int", default=30),
        state=dict(type="str", default="present", choices=["present", "absent"]),
        {{ id_param }}=dict(type="str", required=False),
{% for field in fields %}
        {{ field.snake_name }}=dict(
            type="{{ field.type }}",
            required=False,
{% if field.default is not none %}
{% if field.default is sameas true %}
            default=True,
{% elif field.default is sameas false %}
            default=False,
{% elif field.default is string %}
            default="{{ field.default }}",
{% else %}
            default={{ field.default }},
{% endif %}
{% endif %}
{% if field.type == 'list' and field.elements is defined %}
            elements="{{ field.elements }}",
{% endif %}
        ),
{% endfor %}
    )

    # Field definitions for payload building
    fields = [
{% for field in fields %}
        {"snake_name": "{{ field.snake_name }}", "name": "{{ field.name }}"},
{% endfor %}
    ]

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True,
        required_if=[
            ("state", "present", ("{{ lookup_field }}",), False),
        ],
    )

    # Initialize client
    client = RemnawaveClient(
        api_url=module.params["api_url"],
        api_token=module.params["api_token"],
        validate_certs=module.params["validate_certs"],
        timeout=module.params["timeout"],
    )

{% if resolve_uuid_by_name %}
    # Resolve config profile name to UUID if specified
    if module.params.get("config_profile"):
        cp = module.params["config_profile"]
        name_val = cp.get("active_config_profile")
        uuid_val = cp.get("active_config_profile_uuid")

        if name_val and uuid_val:
            module.fail_json(msg="Cannot specify both active_config_profile and active_config_profile_uuid")

        if name_val:
            resolved_uuid = resolve_config_profile_uuid(client, name_val)
            if not resolved_uuid:
                module.fail_json(msg=f"Config profile '{name_val}' not found")
            # Replace name with resolved UUID
            module.params["config_profile"]["active_config_profile_uuid"] = resolved_uuid
            del module.params["config_profile"]["active_config_profile"]

        # Resolve inbound tags to UUIDs if specified
        profile_uuid = module.params["config_profile"].get("active_config_profile_uuid")
        inbound_tags = cp.get("active_inbound_tags")
        inbound_uuids = cp.get("active_inbounds")

        if inbound_tags and inbound_uuids:
            module.fail_json(msg="Cannot specify both active_inbound_tags and active_inbounds")

        if inbound_tags:
            if not profile_uuid:
                module.fail_json(msg="active_inbound_tags requires active_config_profile or active_config_profile_uuid")
            try:
                resolved_uuids = resolve_inbound_uuids(client, profile_uuid, inbound_tags)
                module.params["config_profile"]["active_inbounds"] = resolved_uuids
                del module.params["config_profile"]["active_inbound_tags"]
            except ValueError as e:
                module.fail_json(msg=str(e))

{% endif %}
    state = module.params["state"]
    resource_id = module.params.get("{{ id_param }}")
    lookup_value = module.params.get("{{ lookup_field }}")

    result = dict(
        changed=False,
        msg="",
    )

    try:
        # Find existing resource
        existing = None
        if resource_id:
            existing = client.get_one("{{ endpoints['get_one']['path'] }}", resource_id)
        elif lookup_value:
            all_resources = client.get_all("{{ endpoints['get_all']['path'] }}")
            for resource in all_resources:
                if resource.get("{{ lookup_field }}") == lookup_value:
                    existing = resource
                    resource_id = resource.get("{{ id_param }}")
                    break

        if state == "absent":
            if existing:
                if module.check_mode:
                    result["changed"] = True
                    result["msg"] = "{{ resource_name }} would be deleted"
                    result["diff"] = {"before": camel_to_snake_dict(existing), "after": {}}
                else:
                    client.delete("{{ endpoints['delete']['path'] }}", resource_id)
                    result["changed"] = True
                    result["msg"] = "{{ resource_name }} deleted successfully"
            else:
                result["msg"] = "{{ resource_name }} does not exist"
            module.exit_json(**result)

        # state == "present"
        payload = build_payload(module.params, fields)

        if not existing:
            # CREATE
            if module.check_mode:
                result["changed"] = True
                result["msg"] = "{{ resource_name }} would be created"
                result["diff"] = {"before": {}, "after": camel_to_snake_dict(payload)}
            else:
                response = client.create("{{ endpoints['create']['path'] }}", payload)
                result["changed"] = True
                result["response"] = camel_to_snake_dict(response)
                result["msg"] = "{{ resource_name }} created successfully"
        else:
            # UPDATE - check if changes needed
            diff = recursive_diff(payload, existing)
            if diff:
                if module.check_mode:
                    result["changed"] = True
                    result["msg"] = "{{ resource_name }} would be updated"
                    result["diff"] = {
                        "before": camel_to_snake_dict(existing),
                        "after": camel_to_snake_dict({**existing, **payload}),
                    }
                else:
                    # Add ID to payload for update
                    payload["{{ id_param }}"] = resource_id
                    response = client.update("{{ endpoints['update']['path'] }}", payload, resource_id)
                    result["changed"] = True
                    result["response"] = camel_to_snake_dict(response)
                    result["msg"] = "{{ resource_name }} updated successfully"
            else:
                result["response"] = camel_to_snake_dict(existing)
                result["msg"] = "{{ resource_name }} is already in desired state"

        module.exit_json(**result)

    except RemnawaveAPIError as e:
        result["status_code"] = e.status_code
        result["response_body"] = e.response_body
        result["request_url"] = e.url
        result["request_method"] = e.method
        result.pop("msg", None)
        module.fail_json(msg=str(e), **result)
    except Exception as e:
        result.pop("msg", None)
        module.fail_json(msg=str(e), **result)


def main():
    """Entry point."""
    run_module()


if __name__ == "__main__":
    main()
