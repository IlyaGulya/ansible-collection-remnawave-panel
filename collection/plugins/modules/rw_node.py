#!/usr/bin/python
# -*- coding: utf-8 -*-

# ⚠️ AUTOMATICALLY GENERATED - DO NOT EDIT
# Generated by remnawave-ansible-gen

"""Ansible module for managing Node resources in Remnawave panel."""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r"""
---
module: rw_node
short_description: Manage Remnawave panel nodes
version_added: "1.0.0"
description:
    - Create, update, and delete Node resources in Remnawave panel.
    - Supports check mode for dry-run operations.
    - Implements idempotency by comparing desired state with current state.
options:
    api_url:
        description:
            - The URL of the Remnawave panel API.
            - Can be set via the C(REMNAWAVE_API_URL) environment variable.
        type: str
        required: true
    api_token:
        description:
            - The API token for authentication.
            - Can be set via the C(REMNAWAVE_API_TOKEN) environment variable.
        type: str
        required: true
        no_log: true
    state:
        description:
            - The desired state of the resource.
            - C(present) ensures the resource exists with the specified configuration.
            - C(absent) ensures the resource does not exist.
        type: str
        default: present
        choices:
            - present
            - absent
    uuid:
        description:
            - The unique identifier of the Node.
            - Required when updating or deleting an existing resource by ID.
        type: str
        required: false
    name:
        description:
            - The name field
        type: str
        required: true
    address:
        description:
            - The address field
        type: str
        required: true
    port:
        description:
            - The port field
            - Minimum: 1
            - Maximum: 65535
        type: int
        required: false
    is_traffic_tracking_active:
        description:
            - The isTrafficTrackingActive field
        type: bool
        required: false
        default: False
    traffic_limit_bytes:
        description:
            - The trafficLimitBytes field
            - Minimum: 0
        type: int
        required: false
    notify_percent:
        description:
            - The notifyPercent field
            - Minimum: 0
            - Maximum: 100
        type: int
        required: false
    traffic_reset_day:
        description:
            - The trafficResetDay field
            - Minimum: 1
            - Maximum: 31
        type: int
        required: false
    country_code:
        description:
            - The countryCode field
        type: str
        required: false
        default: XX
    consumption_multiplier:
        description:
            - The consumptionMultiplier field
            - Minimum: 0
            - Maximum: 100
        type: float
        required: false
    config_profile:
        description:
            - The configProfile field
        type: dict
        required: true
    provider_uuid:
        description:
            - The providerUuid field
            - Format: uuid
        type: str
        required: false
    tags:
        description:
            - The tags field
        type: list
        required: false
        elements: str
author:
    - Remnawave Contributors
notes:
    - Supports check_mode for dry-run operations.
    - Uses the name field for resource lookup when uuid is not provided.
"""

EXAMPLES = r"""
- name: Create a new node
  remnawave.panel.rw_node:
    api_url: "https://panel.example.com"
    api_token: "{{ api_token }}"
    state: present
    name: "example_value"
    address: "example_value"
    config_profile: "example_value"

- name: Update an existing node
  remnawave.panel.rw_node:
    api_url: "https://panel.example.com"
    api_token: "{{ api_token }}"
    state: present
    uuid: "existing-uuid-here"
    name: "updated_value"
    address: "updated_value"
    config_profile: "updated_value"

- name: Delete a node
  remnawave.panel.rw_node:
    api_url: "https://panel.example.com"
    api_token: "{{ api_token }}"
    state: absent
    uuid: "uuid-to-delete"

- name: Delete a node by name
  remnawave.panel.rw_node:
    api_url: "https://panel.example.com"
    api_token: "{{ api_token }}"
    state: absent
    name: "resource-name-to-delete"
"""

RETURN = r"""
changed:
    description: Whether the resource was changed.
    type: bool
    returned: always
response:
    description: The API response containing the resource data.
    type: dict
    returned: when resource is created or updated
    sample:
        uuid: "550e8400-e29b-41d4-a716-446655440000"
        name: "example"
        address: "example"
        port: "example"
        isTrafficTrackingActive: "example"
        trafficLimitBytes: "example"
        notifyPercent: "example"
        trafficResetDay: "example"
        countryCode: "example"
        consumptionMultiplier: "example"
        configProfile: "example"
        providerUuid: "example"
        tags: "example"
diff:
    description: The difference between desired and current state.
    type: dict
    returned: when in check_mode and changes would be made
    contains:
        before:
            description: The current state of the resource.
            type: dict
        after:
            description: The desired state of the resource.
            type: dict
msg:
    description: A message describing the result of the operation.
    type: str
    returned: always
"""

from ansible.module_utils.basic import AnsibleModule
from ansible_collections.remnawave.panel.plugins.module_utils.remnawave import (
    RemnawaveClient,
    camel_to_snake_dict,
    recursive_diff,
    snake_to_camel_dict,
)


def build_payload(params, fields):
    """Build the API payload from module parameters."""
    payload = {}
    for field in fields:
        snake_name = field["snake_name"]
        camel_name = field["name"]
        value = params.get(snake_name)
        if value is not None:
            # Convert nested dict keys from snake_case to camelCase
            if isinstance(value, dict):
                value = snake_to_camel_dict(value)
            elif isinstance(value, list):
                value = [snake_to_camel_dict(item) if isinstance(item, dict) else item for item in value]
            payload[camel_name] = value
    return payload


def run_module():
    """Main module execution."""
    # Define argument spec
    module_args = dict(
        api_url=dict(type="str", required=True, fallback=(lambda: None, [])),
        api_token=dict(type="str", required=True, no_log=True, fallback=(lambda: None, [])),
        state=dict(type="str", default="present", choices=["present", "absent"]),
        uuid=dict(type="str", required=False),
        name=dict(
            type="str",
            required=False,
        ),
        address=dict(
            type="str",
            required=False,
        ),
        port=dict(
            type="int",
            required=False,
        ),
        is_traffic_tracking_active=dict(
            type="bool",
            required=False,
            default=False,
        ),
        traffic_limit_bytes=dict(
            type="int",
            required=False,
        ),
        notify_percent=dict(
            type="int",
            required=False,
        ),
        traffic_reset_day=dict(
            type="int",
            required=False,
        ),
        country_code=dict(
            type="str",
            required=False,
            default="XX",
        ),
        consumption_multiplier=dict(
            type="float",
            required=False,
        ),
        config_profile=dict(
            type="dict",
            required=False,
        ),
        provider_uuid=dict(
            type="str",
            required=False,
        ),
        tags=dict(
            type="list",
            required=False,
            elements="str",
        ),
    )

    # Field definitions for payload building
    fields = [
        {"snake_name": "name", "name": "name"},
        {"snake_name": "address", "name": "address"},
        {"snake_name": "port", "name": "port"},
        {"snake_name": "is_traffic_tracking_active", "name": "isTrafficTrackingActive"},
        {"snake_name": "traffic_limit_bytes", "name": "trafficLimitBytes"},
        {"snake_name": "notify_percent", "name": "notifyPercent"},
        {"snake_name": "traffic_reset_day", "name": "trafficResetDay"},
        {"snake_name": "country_code", "name": "countryCode"},
        {"snake_name": "consumption_multiplier", "name": "consumptionMultiplier"},
        {"snake_name": "config_profile", "name": "configProfile"},
        {"snake_name": "provider_uuid", "name": "providerUuid"},
        {"snake_name": "tags", "name": "tags"},
    ]

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True,
        required_if=[
            ("state", "present", ("name",), False),
        ],
    )

    # Initialize client
    client = RemnawaveClient(
        api_url=module.params["api_url"],
        api_token=module.params["api_token"],
        module=module,
    )

    state = module.params["state"]
    resource_id = module.params.get("uuid")
    lookup_value = module.params.get("name")

    result = dict(
        changed=False,
        msg="",
    )

    try:
        # Find existing resource
        existing = None
        if resource_id:
            existing = client.get_one("/api/nodes/{uuid}", resource_id)
        elif lookup_value:
            all_resources = client.get_all("/api/nodes")
            for resource in all_resources:
                if resource.get("name") == lookup_value:
                    existing = resource
                    resource_id = resource.get("uuid")
                    break

        if state == "absent":
            if existing:
                if module.check_mode:
                    result["changed"] = True
                    result["msg"] = "Node would be deleted"
                    result["diff"] = {"before": camel_to_snake_dict(existing), "after": {}}
                else:
                    client.delete("/api/nodes/{uuid}", resource_id)
                    result["changed"] = True
                    result["msg"] = "Node deleted successfully"
            else:
                result["msg"] = "Node does not exist"
            module.exit_json(**result)

        # state == "present"
        payload = build_payload(module.params, fields)

        if not existing:
            # CREATE
            if module.check_mode:
                result["changed"] = True
                result["msg"] = "Node would be created"
                result["diff"] = {"before": {}, "after": camel_to_snake_dict(payload)}
            else:
                response = client.create("/api/nodes", payload)
                result["changed"] = True
                result["response"] = camel_to_snake_dict(response)
                result["msg"] = "Node created successfully"
        else:
            # UPDATE - check if changes needed
            diff = recursive_diff(payload, existing)
            if diff:
                if module.check_mode:
                    result["changed"] = True
                    result["msg"] = "Node would be updated"
                    result["diff"] = {
                        "before": camel_to_snake_dict(existing),
                        "after": camel_to_snake_dict({**existing, **payload}),
                    }
                else:
                    # Add ID to payload for update
                    payload["uuid"] = resource_id
                    response = client.update("/api/nodes", payload, resource_id)
                    result["changed"] = True
                    result["response"] = camel_to_snake_dict(response)
                    result["msg"] = "Node updated successfully"
            else:
                result["response"] = camel_to_snake_dict(existing)
                result["msg"] = "Node is already in desired state"

        module.exit_json(**result)

    except Exception as e:
        result.pop("msg", None)  # Remove msg to avoid duplicate keyword argument
        module.fail_json(msg=str(e), **result)


def main():
    """Entry point."""
    run_module()


if __name__ == "__main__":
    main()
