#!/usr/bin/python
# -*- coding: utf-8 -*-

# ⚠️ AUTOMATICALLY GENERATED - DO NOT EDIT
# Generated by remnawave-ansible-gen

"""Shared utilities for Remnawave Ansible modules."""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

import json
import re
from urllib.error import HTTPError, URLError
from urllib.request import Request, urlopen

# Read-only fields that should be ignored during comparison
READ_ONLY_FIELDS = {
    "uuid",
    "createdAt",
    "updatedAt",
    "isConnected",
    "isConnecting",
    "isDisabled",
    "lastStatusChange",
    "lastStatusMessage",
    "xrayVersion",
    "usersOnline",
    "cpuCount",
    "cpuModel",
    "totalRam",
    "publicIp",
    "isXrayRunning",
    "viewPosition",
    "nodesCount",
    "totalUsedTrafficBytes",
    "usedTrafficBytes",
    "activeInbounds",
}


def to_snake_case(name):
    """Convert camelCase to snake_case."""
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def to_camel_case(name):
    """Convert snake_case to camelCase."""
    components = name.split("_")
    return components[0] + "".join(x.title() for x in components[1:])


def camel_to_snake_dict(d):
    """Recursively convert dictionary keys from camelCase to snake_case."""
    if isinstance(d, dict):
        return {to_snake_case(k): camel_to_snake_dict(v) for k, v in d.items()}
    elif isinstance(d, list):
        return [camel_to_snake_dict(item) for item in d]
    return d


def snake_to_camel_dict(d):
    """Recursively convert dictionary keys from snake_case to camelCase."""
    if isinstance(d, dict):
        return {to_camel_case(k): snake_to_camel_dict(v) for k, v in d.items()}
    elif isinstance(d, list):
        return [snake_to_camel_dict(item) for item in d]
    return d


def recursive_diff(desired, current):
    """
    Compare desired state with current state, returning differences.

    Only compares keys present in desired state and ignores read-only fields.
    Returns a dict of differences, or None if no changes needed.
    """
    if desired is None:
        return None

    if not isinstance(desired, dict) or not isinstance(current, dict):
        if desired != current:
            return {"desired": desired, "current": current}
        return None

    diff = {}
    for key, desired_value in desired.items():
        # Skip read-only fields
        if key in READ_ONLY_FIELDS:
            continue

        current_value = current.get(key)

        if isinstance(desired_value, dict):
            nested_diff = recursive_diff(desired_value, current_value or {})
            if nested_diff:
                diff[key] = nested_diff
        elif isinstance(desired_value, list):
            if not _lists_equal(desired_value, current_value or []):
                diff[key] = {"desired": desired_value, "current": current_value}
        elif desired_value != current_value:
            diff[key] = {"desired": desired_value, "current": current_value}

    return diff if diff else None


def _lists_equal(list1, list2):
    """Compare two lists for equality, handling unordered comparison for simple types."""
    if len(list1) != len(list2):
        return False

    # For lists of dicts, compare in order
    if list1 and isinstance(list1[0], dict):
        return list1 == list2

    # For simple types, compare as sets if all items are hashable
    try:
        return set(list1) == set(list2)
    except TypeError:
        return list1 == list2


class RemnawaveClient:
    """HTTP client for Remnawave API."""

    def __init__(self, api_url, api_token, module=None):
        """Initialize the client."""
        self.api_url = api_url.rstrip("/")
        self.api_token = api_token
        self.module = module

    def _request(self, method, path, data=None):
        """Make an HTTP request to the API."""
        url = f"{self.api_url}{path}"
        headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        body = None
        if data is not None:
            body = json.dumps(data).encode("utf-8")

        request = Request(url, data=body, headers=headers, method=method)

        try:
            with urlopen(request, timeout=30) as response:
                response_body = response.read().decode("utf-8")
                if response_body:
                    return json.loads(response_body)
                return None
        except HTTPError as e:
            error_body = e.read().decode("utf-8")
            try:
                error_data = json.loads(error_body)
                error_msg = error_data.get("message", str(e))
            except (json.JSONDecodeError, KeyError):
                error_msg = error_body or str(e)
            raise Exception(f"API request failed ({e.code}): {error_msg}")
        except URLError as e:
            raise Exception(f"Failed to connect to API: {e.reason}")

    def get_all(self, path, list_key=None):
        """Get all resources from a list endpoint.

        The API returns responses like {"response": {"total": N, "items": [...]}}
        This method extracts the list from the nested structure.

        Args:
            path: API endpoint path
            list_key: Optional key name for the list (e.g., "configProfiles", "nodes")
                      If not provided, will find the first list in the response.
        """
        response = self._request("GET", path)
        if response and "response" in response:
            inner = response["response"]
            # If it's already a list, return it
            if isinstance(inner, list):
                return inner
            # If it's a dict, extract the list
            if isinstance(inner, dict):
                if list_key and list_key in inner:
                    return inner[list_key]
                # Find the first list value in the dict
                for value in inner.values():
                    if isinstance(value, list):
                        return value
            return inner
        return response or []

    def get_one(self, path_template, resource_id):
        """Get a single resource by ID."""
        path = path_template.replace("{uuid}", resource_id)
        try:
            response = self._request("GET", path)
            if response and "response" in response:
                return response["response"]
            return response
        except Exception as e:
            if "404" in str(e) or "not found" in str(e).lower():
                return None
            raise

    def create(self, path, data):
        """Create a new resource."""
        response = self._request("POST", path, data)
        if response and "response" in response:
            return response["response"]
        return response

    def update(self, path_template, data, resource_id=None):
        """Update an existing resource."""
        if resource_id:
            path = path_template.replace("{uuid}", resource_id)
        else:
            path = path_template
        response = self._request("PATCH", path, data)
        if response and "response" in response:
            return response["response"]
        return response

    def delete(self, path_template, resource_id):
        """Delete a resource by ID."""
        path = path_template.replace("{uuid}", resource_id)
        return self._request("DELETE", path)


def resolve_config_profile_uuid(client, profile_name):
    """
    Resolve a config profile name to its UUID.

    Args:
        client: RemnawaveClient instance
        profile_name: The name of the config profile to resolve

    Returns:
        The UUID of the config profile if found, None otherwise
    """
    profiles = client.get_all("/api/config-profiles")
    for profile in profiles:
        if profile.get("name") == profile_name:
            return profile.get("uuid")
    return None
