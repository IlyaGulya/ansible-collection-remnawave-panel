# -*- coding: utf-8 -*-

# Copyright: (c) 2026, Ilya Gulya
# MIT License (see LICENSE or https://opensource.org/licenses/MIT)

# ⚠️ AUTOMATICALLY GENERATED - DO NOT EDIT
# Generated by remnawave-ansible-gen

"""Shared utilities for Remnawave Ansible modules."""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

import json
import re

from ansible.module_utils.six.moves.urllib.error import HTTPError, URLError
from ansible.module_utils.urls import open_url


class RemnawaveAPIError(Exception):
    """Exception with structured error information for API failures."""

    def __init__(self, message, status_code=None, response_body=None, url=None, method=None):
        super().__init__(message)
        self.status_code = status_code
        self.response_body = response_body
        self.url = url
        self.method = method


# Read-only fields that should be ignored during comparison
READ_ONLY_FIELDS = {
    "uuid",
    "createdAt",
    "updatedAt",
    "isConnected",
    "isConnecting",
    "isDisabled",
    "lastStatusChange",
    "lastStatusMessage",
    "xrayVersion",
    "usersOnline",
    "cpuCount",
    "cpuModel",
    "totalRam",
    "publicIp",
    "isXrayRunning",
    "viewPosition",
    "nodesCount",
    "totalUsedTrafficBytes",
    "usedTrafficBytes",
    "activeInbounds",
}


def to_snake_case(name):
    """Convert camelCase to snake_case."""
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def to_camel_case(name):
    """Convert snake_case to camelCase."""
    components = name.split("_")
    return components[0] + "".join(x.title() for x in components[1:])


def camel_to_snake_dict(d):
    """Recursively convert dictionary keys from camelCase to snake_case."""
    if isinstance(d, dict):
        return {to_snake_case(k): camel_to_snake_dict(v) for k, v in d.items()}
    elif isinstance(d, list):
        return [camel_to_snake_dict(item) for item in d]
    return d


def snake_to_camel_dict(d):
    """Recursively convert dictionary keys from snake_case to camelCase."""
    if isinstance(d, dict):
        return {to_camel_case(k): snake_to_camel_dict(v) for k, v in d.items()}
    elif isinstance(d, list):
        return [snake_to_camel_dict(item) for item in d]
    return d


def recursive_diff(desired, current):
    """
    Compare desired state with current state, returning differences.

    Only compares keys present in desired state and ignores read-only fields.
    Returns a dict of differences, or None if no changes needed.
    """
    if desired is None:
        return None

    if not isinstance(desired, dict) or not isinstance(current, dict):
        if desired != current:
            return {"desired": desired, "current": current}
        return None

    diff = {}
    for key, desired_value in desired.items():
        # Skip read-only fields
        if key in READ_ONLY_FIELDS:
            continue

        current_value = current.get(key)

        if isinstance(desired_value, dict):
            nested_diff = recursive_diff(desired_value, current_value or {})
            if nested_diff:
                diff[key] = nested_diff
        elif isinstance(desired_value, list):
            if not _lists_equal(desired_value, current_value or []):
                diff[key] = {"desired": desired_value, "current": current_value}
        elif desired_value != current_value:
            diff[key] = {"desired": desired_value, "current": current_value}

    return diff if diff else None


def _lists_equal(list1, list2):
    """Compare two lists for equality, handling unordered comparison for simple types."""
    if len(list1) != len(list2):
        return False

    # For lists of dicts, compare in order
    if list1 and isinstance(list1[0], dict):
        return list1 == list2

    # For simple types, compare as sets if all items are hashable
    try:
        return set(list1) == set(list2)
    except TypeError:
        return list1 == list2


class RemnawaveClient:
    """HTTP client for Remnawave API."""

    def __init__(self, panel_url, api_token, validate_certs=True, timeout=30):
        """Initialize the client."""
        self.panel_url = panel_url.rstrip("/")
        self.api_token = api_token
        self.validate_certs = validate_certs
        self.timeout = timeout

    def _request(self, method, path, data=None):
        """Make an HTTP request to the API."""
        url = f"{self.panel_url}{path}"
        headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        body = None
        if data is not None:
            body = json.dumps(data)

        try:
            response = open_url(
                url,
                data=body,
                headers=headers,
                method=method,
                timeout=self.timeout,
                validate_certs=self.validate_certs,
            )
            response_body = response.read().decode("utf-8")
            if response_body:
                return json.loads(response_body)
            return None
        except HTTPError as e:
            error_body = e.read().decode("utf-8")
            try:
                error_data = json.loads(error_body)
                error_msg = error_data.get("message", str(e))
            except (json.JSONDecodeError, KeyError):
                error_msg = error_body or str(e)
                error_data = None
            raise RemnawaveAPIError(
                message=f"API request failed ({e.code}): {error_msg}",
                status_code=e.code,
                response_body=error_data or error_body,
                url=url,
                method=method,
            )
        except URLError as e:
            raise RemnawaveAPIError(
                message=f"Failed to connect to API: {e.reason}",
                url=url,
                method=method,
            )

    def get_all(self, path, list_key=None):
        """Get all resources from a list endpoint.

        The API returns responses like {"response": {"total": N, "items": [...]}}
        This method extracts the list from the nested structure.

        Args:
            path: API endpoint path
            list_key: Optional key name for the list (e.g., "configProfiles", "nodes")
                      If not provided, will find the first list in the response.
        """
        response = self._request("GET", path)
        if response and "response" in response:
            inner = response["response"]
            # If it's already a list, return it
            if isinstance(inner, list):
                return inner
            # If it's a dict, extract the list
            if isinstance(inner, dict):
                if list_key and list_key in inner:
                    return inner[list_key]
                # Find the first list value in the dict
                for value in inner.values():
                    if isinstance(value, list):
                        return value
            return inner
        return response or []

    def get_one(self, path_template, resource_id):
        """Get a single resource by ID."""
        path = re.sub(r"\{[^}]+\}", resource_id, path_template, count=1)
        try:
            response = self._request("GET", path)
            if response and "response" in response:
                return response["response"]
            return response
        except RemnawaveAPIError as e:
            if e.status_code == 404:
                return None
            raise

    def create(self, path, data):
        """Create a new resource."""
        response = self._request("POST", path, data)
        if response and "response" in response:
            return response["response"]
        return response

    def update(self, path_template, data, resource_id=None):
        """Update an existing resource."""
        if resource_id:
            path = re.sub(r"\{[^}]+\}", resource_id, path_template, count=1)
        else:
            path = path_template
        response = self._request("PATCH", path, data)
        if response and "response" in response:
            return response["response"]
        return response

    def delete(self, path_template, resource_id):
        """Delete a resource by ID."""
        path = re.sub(r"\{[^}]+\}", resource_id, path_template, count=1)
        return self._request("DELETE", path)


def resolve_config_profile_uuid(client, profile_name):
    """
    Resolve a config profile name to its UUID.

    Args:
        client: RemnawaveClient instance
        profile_name: The name of the config profile to resolve

    Returns:
        The UUID of the config profile if found, None otherwise
    """
    profiles = client.get_all("/api/config-profiles")
    for profile in profiles:
        if profile.get("name") == profile_name:
            return profile.get("uuid")
    return None


def resolve_inbound_uuids(client, profile_uuid, inbound_tags):
    """
    Resolve inbound tags to UUIDs within a config profile.

    Args:
        client: RemnawaveClient instance
        profile_uuid: UUID of the config profile
        inbound_tags: List of inbound tags to resolve

    Returns:
        List of resolved UUIDs

    Raises:
        ValueError if any tag is not found
    """
    inbounds = client.get_all(f"/api/config-profiles/{profile_uuid}/inbounds")
    tag_to_uuid = {ib.get("tag"): ib.get("uuid") for ib in inbounds}

    resolved = []
    for tag in inbound_tags:
        if tag not in tag_to_uuid:
            raise ValueError(f"Inbound '{tag}' not found in config profile")
        resolved.append(tag_to_uuid[tag])
    return resolved
